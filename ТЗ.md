# Ростелеком  
Технологии возможностей

# КЕЙС ДЛЯ ЧЕМПИОНАТА: "УМНЫЙ СКЛАД – СИСТЕМА УПРАВЛЕНИЯ СКЛАДСКОЙ ЛОГИСТИКОЙ С ИСПОЛЬЗОВАНИЕМ АВТОНОМНЫХ РОБОТОВ"

## Контекст и актуальность

Современные складские комплексы Ростелекома активно внедряют автоматизацию процессов для повышения эффективности логистических операций. Одним из ключевых направлений является использование автономных роботов для инвентаризации и контроля остатков продукции. Эти роботы перемещаются по складу, сканируют товары и передают данные в центральную систему управления. Существующие решения часто разрознены и не предоставляют единого интерфейса для операторов склада. Требуется создать современное веб-приложение, которое станет единой точкой контроля складских операций с использованием искусственного интеллекта для прогнозирования и оптимизации складских процессов.

## Описание задачи

Участникам предлагается разработать веб-приложение "Умный склад" состоящее из трех основных страниц, backend-сервиса с REST API и интеграции с ИИ для предиктивной аналитики. Система должна принимать данные от автономных роботов, обрабатывать их, предоставлять аналитику и прогнозы по складским остаткам.

## Архитектура приложения

**Структура страниц приложения**

Приложение состоит из трех обязательных страниц:

### 1. Страница авторизации (/login)

Назначение: Вход в систему для сотрудников склада с разграничением прав доступа.

#### Элементы интерфейса:

- Логотип компании – изображение в верхней части страницы
- Форма авторизации – центрированный блок содержащий:
  - Поле ввода логина (input type="text", placeholder="Введите email")
  - Поле ввода пароля (input type="password", placeholder="Введите пароль")
  - Чекбокс "Запомнить меня"
  - Кнопка "Войти" (primary button, ширина 100%)
  - Ссылка "Забыли пароль?" (под формой)
- Индикатор загрузки – появляется при отправке формы
- Блок ошибок – красный alert для отображения ошибок авторизации

#### Валидация:

- Email должен быть в корректном формате
- Пароль минимум 8 символов
- Отображение ошибки при неверных credentials

#### После успешной авторизации:

- Сохранение JWT токена в localStorage
- Редирект на страницу текущего сбора данных

### 2. Страница текущего сбора данных (/dashboard)

Назначение: Мониторинг работы роботов и состояния склада в режиме реального времени.

**Структура страницы:**

Шалка (Header):

- Логотип Ростелеком (слева)
- Название системы "Умный склад"
- Информация о пользователе (справа): имя, роль
- Кнопка "Выход"

Навигационное меню (горизонтальное):

- Текущий мониторинг (активная вкладка)
- Исторические данные
- Загрузить CSV (кнопка справа)

Основная область содержит 4 блока:

**Блок 1: Карта склада (левая половина экрана)**

- Интерактивная SVG карта склада с сеткой зон (A-Z по горизонтали, 1-50 по вертикали)
- Отображение роботов в виде иконок с номерами (зеленые – активные, желтые – low battery, красные – offline)
- При наведении на робота – tooltip с информацией (ID, батарея, последнее обновление)
- Цветовая индикация зон: зеленая – проверена недавно, желтая – требует проверки, красная – критические остатки
- Кнопки масштабирования (+/-) и центрирования карты

**Блок 2: Статистика в реальном времени (правый верхний квадрант)**

- Карточки с ключевыми метриками:
  - Активных роботов: число/общее количество
  - Проверено сегодня: количество позиций
  - Критических остатков: количество SKU
  - Средний заряд батарей: процент
- График активности роботов за последний час (line chart)
- Обновление каждые 5 секунд

**Блок 3: Таблица последних сканирований (правый средний квадрант)**

- Колонки таблицы:
  - Время (чч:мм:сс)
  - ID робота
  - Зона склада
  - Товар (название и артикул)
  - Количество
  - Статус (badge: OK/Hиэкий остаток/Критично)
- Автоскролл при появлении новых записей
- Максимум 20 последних записей
- Кнопка "Пауза" для остановки автообновления

**Блок 4: Предиктивная аналитика от ИИ (правый нижний квадрант)**

- Заголовок "Прогноз ИИ на следующие 7 дней"
- Список из 5 товаров с критическим прогнозом:
  - Название товара
  - Текущий остаток
  - Прогнозируемая дата исчерпания
  - Рекомендуемое количество для заказа
- Кнопка "Обновить прогноз" (вызывает API ИИ)
- Индикатор достоверности прогноза (процент)

WebSocket индикатор (правый нижний угол):

- Зеленый круг – соединение активно
- Красный круг – соединение потеряно
- Серый круг – переподключение

### 3. Страница исторических данных (/history)

Назначение: Анализ исторических данных инвентаризации и формирование отчетов.

Структура страницы:

Шалка и навигация – идентичны странице dashboard

**Панель фильтров (верхняя часть):**

- Выбор периода:
  - Date picker "От" (календарь)
  - Date picker "До" (календарь)
- Быстрые фильтры: Сегодня, Вчера, Неделя, Месяц
- Фильтр по зонам склада (multiselect dropdown)
- Фильтр по категориям товаров (multiselect dropdown)
- Фильтр по статусу (checkboxes): Все, ОК, Низкий остаток, Критично
- Поиск по артикулу или названию (input с иконкой поиска)
- Кнопка "Применить фильтры"
- Кнопка "Сбросить"

**Сводная статистика (горизонтальная полоса):**

- Всего проверок за период: число
- Уникальных товаров: число
- Выявлено расхождений: число
- Среднее время инвентаризации зоны: минуты

**Основная таблица данных:**

- Колонки:
  - Дата и время проверки
  - ID робота
  - Зона склада
  - Артикул товара
  - Название товара
  - Ожидаемое количество
  - Фактическое количество
  - Расхождение (+/-)
  - Статус
- Сортировка по каждой колонке
- Пагинация (20/50/100 записей на странице)
- Возможность выбора записей (checkbox в первой колонке)

**Панель действий (под таблицей):**

- Кнопка "Экспорт в Excel" (для выбранных записей)
- Кнопка "Экспорт в PDF"
- Кнопка "Построить график" (открывает модальное окно)

**График тренда остатков (нижняя часть):**

- Линейный график изменения остатков по выбранным товарам
- Ось X – временная шкала
- Ось Y – количество единиц
- Легенда с названиями товаров
- Возможность скрыть/показать линии товаров

## Функция загрузки CSV

**Модальное окно загрузки CSV:**

Открывается при клике на кнопку "Загрузить CSV" в навигационном меню.

**Элементы окна:**

- Заголовок "Загрузка данных инвентаризации"
- Drag & Drop область:
  - Текст "Перетащите CSV файл сюда или нажмите для выбора"
  - Иконка загрузки
  - При перетаскивании – подсветка области
- Требования к файлу (текст под областью):
  - Формат: CSV с разделителем ";"
  - Кодировка: UTF–8
  - Обязательные колонки: product_id, product_name, quantity, zone, date
- Прогресс–бар загрузки (появляется после выбора файла)
- Таблица предпросмотра (первые 5 строк файла)
- Кнопки:
  - "Отмена" – закрывает окно
  - "Загрузить" – начинает импорт

**Формат CSV файла:**
product_id;product_name;quantity;zone;date;row;shelf
TEL–4567;Роутер RT–AC68U;45;A;2024–03–15;12;3
TEL–8901;Модем DSL–264OU;12;B;2024–03–15;5;2

## Пользовательские пути (User Flow)

**Сценарий 1: Ежедневный мониторинг склада**

1. **Вход в систему**
   - Оператор открывает приложение
   - Вводит email и пароль
   - Система проверяет credentials и выдает JWT токен
   - Автоматический переход на dashboard

2. **Проверка текущего состояния**
   - Оператор видит карту склада с позициями роботов
   - Проверяет статистику активных роботов
   - Просматривает последние сканирования в таблице
   - Обращает внимание на товары с критическими остатками

3. **Работа с предупреждениями**
   - При появлении критического остатка – всплывающее уведомление
   - Оператор кликает на уведомление
   - Система подсвечивает проблемную зону на карте
   - Оператор принимает решение о пополнении

4. **Использование ИИ–прогноза**
   - Оператор проверяет блок предиктивной аналитики
   - Нажимает "Обновить прогноз"
   - Система отправляет последние данные в ИИ-сервис
   - Получает и отображает рекомендации по закупкам

**Сценарий 2: Анализ исторических данных**

1. **Переход к истории**
   - Оператор кликает на вкладку "Исторические данные"
   - Страница загружает данные за последние 24 часа

2. **Настройка фильтров**
   - Выбирает период: последняя неделя
   - Выбирает конкретную зону склада: A
   - Фильтрует по статусу: только критические
   - Применяет фильтры

3. **Анализ данных**
   - Просматривает отфильтрованные записи
   - Сортирует по колонке "Расхождение"
   - Выявляет проблемные товары

4. **Экспорт отчета**
   - Выбирает нужные записи checkbox'ами
   - Нажимает "Экспорт в Excel"
   - Скачивает файл для дальнейшего анализа

**Сценарий 3: Загрузка исторических данных**

1. **Подготовка данных**
   - Оператор получает CSV файл из внешней системы
   - Проверяет соответствие формата

2. **Загрузка файла**
   - Нажимает кнопку "Загрузить CSV"
   - Перетаскивает файл в Drag & Drop область
   - Проверяет предпросмотр данных

3. **Импорт и валидация**
   - Нажимает "Загрузить"
   - Следит за прогресс-баром
   - Получает отчет о загрузке: успешно/ошибки

4. **Проверка результатов**
   - Переходит на страницу исторических данных
   - Фильтрует по дате загрузки
   - Убеждается что данные корректно импортированы

## Техническая реализация

### Backend API endpoints
// Авторизация
POST /api/auth/login
Request: { email: string, password: string }
Response: { token: string, user: { id, name, role } }

// Получение данных от робота
POST /api/robots/data
Headers: { Authorization: "Bearer robot_token" }
Request: { robot_id, timestamp, location, scan_results, battery_level }
Response: { status: "received", message_id: string }

// WebSocket для real-time обновлений
WS /api/ws/dashboard
Messages: { type: "robot_update" | "inventory_alert", data: (...) }

// Получение текущего состояния
GET /api/dashboard/current
Response: { robots: [], recent_scans: [], statistics: {} }

// Исторические данные
GET /api/inventory/history/?from=date&to=date&zone=A&status=critical
Response: { total: number, items: [], pagination: {} }

// Загрузка CSV
POST /api/inventory/import
Content-Type: multipart/form-data
Response: { success: number, failed: number, errors: [] }

// Интеграция с ИИ для прогнозов
POST /api/ai/predict
Request: { period_days: 7, categories: [] }
Response: { predictions: [], confidence: number }

// Экспорт данных
GET /api/export/excel?ids=1,2,3
Response: Binary file stream

## Интеграция с ИИ–сервисом

Для предиктивной аналитики необходимо интегрировать любой из следующих сервисов:

**Вариант 1: OpenAI GPT API**

```javascript
// Формирование пролита для анализа
const prompt = *
Analyze warehouse inventory data and predict stock levels for next 7 days.
Current data: ${JSON.stringify(inventoryData)}
Historical consumption pattern: ${JSON.stringify(historicalData)}
Provide predictions in JSON format with fields: product_id, days_until_stockout,
recommended_order_quantity

// Вызов API
const response = await openai.createCompletion({
model: "gpt-3.5-turbo",
messages: [[ role: "system", content: prompt ],
temperature: 0.3
]);
}

## Интеграция с ИИ–сервисом

Для предиктивной аналитики необходимо интегрировать любой из следующих сервисов:

**Вариант 1: OpenAI GPT API**

```javascript
// Формирование пролита для анализа
const prompt = *
Analyze warehouse inventory data and predict stock levels for next 7 days.
Current data: ${JSON.stringify(inventoryData)}
Historical consumption pattern: ${JSON.stringify(historicalData)}
Provide predictions in JSON format with fields: product_id, days_until_stockout,
recommended_order_quantity

// Вызов API
const response = await openai.createCompletion({
model: "gpt-3.5-turbo",
messages: [[ role: "system", content: prompt ],
temperature: 0.3
]);
}
Вариант 2: Яндекс YandexGPT API
// Использование YandexGPT для анализа на русском языке
const analysisRequest = {
    modelUrl: "gpt://big../yandexgpt-lite",
    completionOptions: {
    stream: false,
    temperature: 0.3,
    maxTokens: 2000
    },
    messages: [
    role: "system",
    text: "Проанализируй данные инвентаризации и спрогнозируй остатки"
    ]
};
Вариант 3: Локальная ML–модель (Python FastAPI)
# Простая модель на основе линейной регрессии
from sklearn.linear_model import LinearRegression
import pandas as pd

def predict_stockout(product_history):
    # Подготовка данных
    df = pd.DataFrame(product_history)
    X = df[days_ago'].values.reshape(-1, 1)
    y = df['quantity'].values

    # Обучение модели
    model = LinearRegression()
    model.fit(X, y)

    # Прогноз на 7 дней
    future_days = np.array(range(-7, 0)).reshape(-1, 1)
    predictions = model.predict(future_days)

    # Поиск дня исчерпания запасов
    stockout_day = next((if for i, q in enumerate(predictions) if q <= 0), None)

    return {
    'days_until_stockout': stockout_day,
    'recommended_order': calculate_optimal_order(product_history)
    }
Структура базы данных
-- Пользователи системы
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    name VARCHAR(255) NOT NULL,
    role VARCHAR(50) NOT NULL, -- 'operator', 'admin', 'viewer'
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Po6orbl
CREATE TABLE robots (
    id VARCHAR(50) PRIMARY KEY, -- 'RB-OO1'
    status VARCHAR(50) DEFAULT 'active',
    battery_level INTEGER,
    last_update TIMESTAMP,
    current_zone VARCHAR(10),
    current_row INTEGER,
    current_shelf INTEGER
);

-- Tosapbl
CREATE TABLE products (
    id VARCHAR(50) PRIMARY KEY, -- 'TEL-4567'
    name VARCHAR(255) NOT NULL,
    category VARCHAR(100),
    min_stock INTEGER DEFAULT 10,
    optimal_stock INTEGER DEFAULT 100
);

-- История инвентаризации
CREATE TABLE inventory_history (
    id SERIAL PRIMARY KEY,
    robot_id VARCHAR(50) REFERENCES robots(id),
    product_id VARCHAR(50) REFERENCES products(id),
    quantity INTEGER NOT NULL,
    zone VARCHAR(10) NOT NULL,
    row_number INTEGER,
    shelf_number INTEGER,
    status VARCHAR(50), -- 'OK', 'LOW_STOCK', 'CRITICAL'
    scanned_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Прогнозы ИИ
CREATE TABLE al_predictions (
    id SERIAL PRIMARY KEY,
    product_id VARCHAR(50) REFERENCES products(id),
    prediction_date DATE NOT NULL,
    days_until_stockout INTEGER,
    recommended_order INTEGER,
    confidence_score DECIMAL(3,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Индексы для оптимизации  
CREATE INDEX idx_inventory_scanned ON inventory_history(scanned_at DESC);  
CREATE INDEX idx_inventory_product ON inventory_history(product_id);  
CREATE INDEX idx_inventory_zone ON inventory_history(zone);

Docker-compose для развертывания
version: '3.8'

services:
  # PostgreSQL база данных
  postgres:
    image: postgres:i5
    environment:
      POSTGRES_DB: warehouse_db
      POSTGRES_USER: warehouse_user
      POSTGRES_PASSWORD: secure_password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U warehouse_user"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis для кеширования и WebSocket
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Backend API
  backend:
    build: ./backend
    environment:
      DATABASE_URL: postgresql://warehouse_usersecure_password@postgres:5432/warehouse_db
      REDIS_URL: redis://redis:6379
      JWT_SECRET: your_jwt_secret_key
      ALAPLKEY: your_ai_api_key
      AL_SERVICE: openai # или yandex, local
    ports:
      - "3000:3000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - ./uploads:/app/uploads

  # Frontend приложение
  frontend:
    build: ./frontend
    environment:
      REACT_APP_APL_URL: http://localhost:3000
      REACT_APP_WS_URL: ws://localhost:3000
    ports:
      - "80:80"
    depends_on:
      - backend

  # Эмулятор роботов для тестирования
  robot_emulator:
    build: ./robot_emulator
    environment:
      APL_URL: http://backend:3000
      ROBOTS_COUNT: 5
      UPDATE_INTERVAL: 10 # секунды
    depends_on:
      - backend

volumes:
  postgres_data:

Эмулятор роботов (Python)
# robot_emulator/emulator.py
import json
import time
import random
import requests
from datetime import datetime
import os

class RobotEmulator:
    def __init__(self, robot_id, api_url):
        self.robot_id = robot_id
        self.api_url = api_url
        self.battery = 100
        self.current_zone = 'A'
        self.current_row = 1
        self.current_shelf = 1

        # Список тестовых товаров
        self.products = [
            {"id": "TEL-4567", "name": "Poyrep RT-AC68U"},
            {"id": "TEL-8901", "name": "Mодем DSL-2640U"},
            {"id": "TEL-2345", "name": "Коммутатор SG-108"},
            {"id": "TEL-6789", "name": "IP-телефон T46S"},
            {"id": "TEL-3456", "name": "Кабель UTP Cat6"}
        ]

    def generate_scan_data(self):
        """Тенерация данных сканирования"""
        scanned_products = random.sample(self.products, k=random.randint(1, 3))
        scan_results = []

        for product in scanned_products:
            quantity = random.randint(5, 100)
            status = "OK" if quantity > 20 else ("LOW_STOCK" if quantity > 10 else "CRITICAL")

            scan_results.append({
                "product_id": product["id"],
                "product_name": product["name"],
                "quantity": quantity,
                "status": status
            })

        return scan_results

    def move_to_next_location(self):
        """Перемещение робота к следующей локации"""
        self.current_shelf += 1
        if self.current_shelf > 10:
            self.current_shelf = 1
            self.current_row += 1
            if self.current_row > 20:
                self.current_row = 1
                # Переход к следующей зоне
                self.current_zone = chr(ord(self.current_zone) + 1)
                if ord(self.current_zone) > ord('E'):
                    self.current_zone = 'A'

        # Расход батареи
        self.battery -= random.uniform(0.1, 0.5)
        if self.battery < 20:
            self.battery = 100 # Симуляция зарядки

    def send_data(self):
        """Отправка данных на сервер"""
        data = {
            "robot_id": self.robot_id,
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "location": {
                "zone": self.current_zone,
                "row": self.current_row,
                "shelf": self.current_shelf
            },
            "scan_results": self.generate_scan_data(),
            "battery_level": round(self.battery, 1),
            "next_checkpoint": f"{self.current_zone}-{self.current_row+1}-{self.current_shelf}"
        }

        try:
            response = requests.post(
                f"{self.api_url}/api/robots/data",
                json=data,
                headers={
                    "Authorization": f"{Bearer robot_token._{self.robot_id}",
                    "Content-Type": "application/json"
                }
            )
            if response.status_code == 200:
                print(f"{[self.robot_id]} Data sent successfully")
            else:
                print(f"{[self.robot_id]} Error: {response.status_code}")
        except Exception as e:
            print(f"{[self.robot_id]} Connection error: {e}")

    def run(self):
        """OchoBhoM цикл работы робота"""
        while True:
            self.send_data()
            self.move_to_next_location()
            time.sleep(int(os.getenv('UPDATE_INTERVAL', 10)))

if __name__ == "__main__":
    api_url = os.getenv('API_URL', 'http://localhost:3000')
    robots_count = int(os.getenv('ROBOTS_COUNT', 5))

    # Запуск эмуляторов роботов
    import threading

    for i in range(1, robots_count + 1):
        robot = RobotEmulator(f"{RB-{i:O3d}", api_url)
        thread = threading.Thread(target=robot.run)
        thread.daemon = True
        thread.start()

    # Держим главный поток активным
    while True:
        time.sleep(60)

Критерии оценки (детализированные)
Функциональность (40 баллов)

Корректная авторизация с JWT токенами – 5 баллов

Отображение real-time данных через WebSocket – 8 баллов

Работающая карта склада с позициями роботов – 7 баллов

Фильтрация и поиск в исторических данных – 5 баллов

Корректная загрузка и парсинг CSV – 5 баллов

Интеграция с ИИ и отображение прогнозов – 10 баллов

Архитектура и код (30 баллов)

Чистая архитектура с разделением на слои – 8 баллов

Обработка ошибок и исключений – 5 баллов

Использование паттернов проектирования – 5 баллов

Оптимизация запросов к БД – 5 баллов

Наличие unit–тестов – 7 баллов

Пользовательский опыт (20 баллов)

Responsive дизайн для разных экранов – 5 баллов

Плавные анимации и переходы – 3 балла

Информативные сообщения об ошибках – 3 балла

Логичная навигация – 4 балла

Скорость загрузки страниц < 2 сек – 5 баллов

Развертывание и документация (10 баллов)

Работающий docker–compose – 3 балла

README с инструкциями – 2 балла

API документация (Swagger) – 3 балла

Комментарии в коде – 2 балла

Минимальные требования для зачета
Для успешной удачи проекта команда должна реализовать:

Все три страницы с базовым функционалом (авторизация, dashboard, история)

REST API для приема данных от роботов (можно тестировать эмулятором)

WebSocket соединение для хотя бы одного типа обновлений

Загрузку CSV с валидацией формата

Интеграцию с любым ИИ–сервисом (даже mock–реализация с случайными данными засчитывается при наличии правильной архитектуры)

Docker–compose файл для запуска всех сервисов одной командой

Базовую документацию в README файле

Рекомендуемый стек технологий
Backend:

Node.js + Express + TypeScript

Python + FastAPI + SQLAlchemy

Java + Spring Boot

C# + ASP.NET Core

Frontend:

React + Redux Toolkit + Material-UI

Vue 3 + Vuex + Vuetify

Angular + RxJS + Angular Material

База данных:

PostgreSQL (рекомендуется)

MongoDB (для NoSQL подхода)

Дополнительно:

Redis для кеширования

Socket.io для WebSocket

Bull для очередей задач

Jest/Pytest для тестирования

Данное описание содержит все необходимые детали для немедленного начала разработки. Участники получают четкое представление о требуемом функционале, структуре интерфейсов и технической реализации. При возникновении вопросов команды могут обращаться к данному документу как к исчерпывающей спецификации проекта.